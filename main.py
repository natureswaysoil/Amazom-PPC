"""
Google Cloud Function Entry Point for Amazon PPC Optimizer
Triggered by Cloud Scheduler via HTTP request

This function automatically refreshes Amazon Advertising API tokens before making API calls.
Token refresh is handled automatically by the optimizer_core module.
"""

import json
import logging
import os
import sys
import traceback
import tempfile
from contextlib import contextmanager
from datetime import datetime
from typing import Dict, Optional, Tuple, Any
import functions_framework
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import requests
import yaml

# Add parent directory to path to import optimizer
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Configure logging for Cloud Functions
# Detect if running in Cloud Functions environment
IS_CLOUD_FUNCTION = os.getenv('K_SERVICE') is not None or os.getenv('FUNCTION_TARGET') is not None

if IS_CLOUD_FUNCTION:
    # Use only StreamHandler for Cloud Functions (logs go to Cloud Logging)
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[logging.StreamHandler(sys.stdout)]
    )
else:
    # For local development, use both console and file logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler(f'ppc_main_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log')
        ]
    )

logger = logging.getLogger(__name__)


@contextmanager
def create_config_file(config_dict: Dict) -> str:
    """
    Create a temporary config file from dictionary using context manager
    The optimizer_core expects YAML format file, so we ensure consistent format handling
    
    Args:
        config_dict: Configuration dictionary (from JSON or other source)
        
    Yields:
        Path to temporary YAML config file
        
    Raises:
        ValueError: If config_dict is invalid
        IOError: If file creation fails
    """
    if not isinstance(config_dict, dict):
        raise ValueError("config_dict must be a dictionary")
    
    temp_file = None
    try:
        # Create temp file with YAML format (optimizer_core expects YAML)
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False, encoding='utf-8')
        yaml.dump(config_dict, temp_file, default_flow_style=False, allow_unicode=True)
        temp_file.close()
        logger.info(f"Created temporary config file: {temp_file.name}")
        yield temp_file.name
    except Exception as e:
        logger.error(f"Failed to create config file: {e}")
        if temp_file and os.path.exists(temp_file.name):
            try:
                os.unlink(temp_file.name)
            except Exception as cleanup_err:
                logger.warning(f"Failed to cleanup temp file: {cleanup_err}")
        raise
    finally:
        # Cleanup temp file
        if temp_file and os.path.exists(temp_file.name):
            try:
                os.unlink(temp_file.name)
                logger.debug(f"Cleaned up temporary config file: {temp_file.name}")
            except Exception as e:
                logger.warning(f"Failed to cleanup temp file {temp_file.name}: {e}")


def send_email_notification(subject: str, body: str, config: Dict) -> bool:
    """
    Send email notification via SMTP with retry logic
    
    Args:
        subject: Email subject line
        body: Plain text email body
        config: Configuration dictionary containing email settings
        
    Returns:
        True if email sent successfully, False otherwise
    """
    try:
        email_config = config.get('email_notifications', {})
        if not email_config.get('enabled', False):
            logger.info("Email notifications disabled")
            return True
        
        # Validate required email config fields
        required_fields = ['smtp_host', 'smtp_port', 'smtp_user', 'smtp_password', 'from_email', 'to_email']
        missing_fields = [field for field in required_fields if not email_config.get(field)]
        if missing_fields:
            logger.error(f"Missing required email configuration fields: {', '.join(missing_fields)}")
            return False
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = email_config['from_email']
        msg['To'] = email_config['to_email']
        
        # Create HTML version
        dashboard_url = config.get('dashboard', {}).get('url', '#')
        html_body = f"""
        <html>
        <head></head>
        <body>
            <h2>{subject}</h2>
            <div style="font-family: Arial, sans-serif;">
                {body.replace(chr(10), '<br>')}
            </div>
            <hr>
            <p style="color: #666; font-size: 12px;">
                Generated by Amazon PPC Optimizer on Google Cloud Functions<br>
                Dashboard: <a href="{dashboard_url}">View Dashboard</a>
            </p>
        </body>
        </html>
        """
        
        msg.attach(MIMEText(body, 'plain'))
        msg.attach(MIMEText(html_body, 'html'))
        
        # Send via SMTP with retry logic
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                with smtplib.SMTP(email_config['smtp_host'], int(email_config['smtp_port']), timeout=30) as server:
                    server.starttls()
                    server.login(email_config['smtp_user'], email_config['smtp_password'])
                    server.send_message(msg)
                
                logger.info(f"Email notification sent to {email_config['to_email']}")
                return True
                
            except (smtplib.SMTPException, OSError) as smtp_err:
                if attempt < max_retries - 1:
                    logger.warning(f"Email send attempt {attempt + 1}/{max_retries} failed: {smtp_err}. Retrying...")
                    import time
                    time.sleep(retry_delay * (attempt + 1))
                else:
                    logger.error(f"Failed to send email after {max_retries} attempts: {smtp_err}")
                    return False
        
        return False
        
    except Exception as e:
        logger.error(f"Failed to send email notification: {str(e)}")
        return False


def update_dashboard(results: Dict, config: Dict) -> bool:
    """
    Send optimization results to the dashboard
    
    Args:
        results: Optimization results dictionary
        config: Configuration dictionary containing dashboard settings
        
    Returns:
        True if dashboard updated successfully, False otherwise
    """
    try:
        dashboard_url = config.get('dashboard', {}).get('url', None)
        if not dashboard_url:
            logger.warning("Dashboard URL not configured, skipping dashboard update")
            return True
        
        # Send POST request to dashboard API endpoint
        api_endpoint = f"{dashboard_url}/api/optimization-results"
        
        payload = {
            'timestamp': datetime.now().isoformat(),
            'results': results,
            'status': 'success'
        }
        
        response = requests.post(
            api_endpoint,
            json=payload,
            headers={'Content-Type': 'application/json'},
            timeout=10
        )
        
        if response.status_code == 200:
            logger.info("Dashboard updated successfully")
            return True
        else:
            logger.warning(f"Dashboard update returned status {response.status_code}")
            return False
            
    except Exception as e:
        logger.error(f"Failed to update dashboard: {str(e)}")
        return False


@functions_framework.http
def run_optimizer(request) -> Tuple[Dict[str, Any], int]:
    """
    Cloud Function entry point - triggered by Cloud Scheduler
    
    The optimizer automatically refreshes the Amazon Advertising API access token
    before making API calls using the refresh_token stored in environment variables.
    
    Args:
        request: HTTP request object (from Cloud Scheduler)
        
    Returns:
        Tuple of (response dictionary, HTTP status code)
    """
    
    start_time = datetime.now()
    logger.info(f"=== Amazon PPC Optimizer Started at {start_time} ===")
    
    try:
        # Load configuration from environment or file
        config = load_config()
        
        # Set environment variables for the optimizer
        # The optimizer reads credentials from environment variables
        set_environment_variables(config)
        
        # Validate required credentials
        validate_credentials(config)
        
        # Check if this is a dry run
        dry_run = request.args.get('dry_run', 'false').lower() == 'true'
        
        # Use context manager for temp config file (ensures cleanup)
        with create_config_file(config) as config_file_path:
            # Get profile ID with default value
            profile_id = config.get('amazon_api', {}).get('profile_id', '')
            if not profile_id:
                raise ValueError("profile_id is required in amazon_api configuration")
            
            # Initialize optimizer
            logger.info("Initializing optimizer...")
            
            # Import here to ensure environment variables are set first
            from optimizer_core import PPCAutomation
            
            optimizer = PPCAutomation(
                config_path=config_file_path,
                profile_id=profile_id,
                dry_run=dry_run
            )
            
            # Run optimization
            # The optimizer will automatically refresh the access token if needed
            logger.info("Running optimization (token refresh handled automatically)...")
            results = optimizer.run()
        
        # Update dashboard
        logger.info("Updating dashboard...")
        update_dashboard(results, config)
        
        # Prepare summary
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        summary = format_results_summary(results, duration, dry_run)
        
        # Send email notification
        if config.get('email_notifications', {}).get('send_on_completion', True):
            subject = f"Amazon PPC Optimization {'(DRY RUN) ' if dry_run else ''}Completed Successfully"
            send_email_notification(subject, summary, config)
        
        logger.info(f"=== Optimization Completed in {duration:.2f} seconds ===")
        
        return {
            'status': 'success',
            'message': 'Optimization completed successfully',
            'results': results,
            'duration_seconds': duration,
            'dry_run': dry_run
        }, 200
        
    except Exception as e:
        error_msg = str(e)
        error_trace = traceback.format_exc()
        logger.error(f"Optimization failed: {error_msg}")
        logger.error(error_trace)
        
        # Send error notification
        try:
            config = load_config()
            if config.get('email_notifications', {}).get('send_on_error', True):
                subject = "Amazon PPC Optimization FAILED"
                body = f"""
Optimization Run Failed

Error: {error_msg}

Timestamp: {datetime.now().isoformat()}

Stack Trace:
{error_trace}

Please check the Cloud Functions logs for more details.
                """
                send_email_notification(subject, body, config)
        except Exception as notification_err:
            logger.warning(f"Failed to send error notification: {notification_err}")
        
        return {
            'status': 'error',
            'message': error_msg,
            'timestamp': datetime.now().isoformat()
        }, 500


def load_config() -> Dict[str, Any]:
    """
    Load configuration from environment variables or config file
    
    Returns:
        Configuration dictionary loaded from JSON
        
    Raises:
        ValueError: If no valid configuration is found
        json.JSONDecodeError: If JSON parsing fails
    """
    
    # Check if config is in environment variable (recommended for Cloud Functions)
    config_json = os.environ.get('PPC_CONFIG', None)
    if config_json:
        logger.info("Loading config from environment variable")
        try:
            config = json.loads(config_json)
            logger.info("Configuration successfully loaded from environment variable")
            return config
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse PPC_CONFIG JSON: {e}")
            raise ValueError(f"Invalid JSON in PPC_CONFIG environment variable: {e}")
    
    # Fall back to config.json file
    config_file = os.path.join(os.path.dirname(__file__), 'config.json')
    if os.path.exists(config_file):
        logger.info(f"Loading config from {config_file}")
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            logger.info(f"Configuration successfully loaded from {config_file}")
            return config
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse config.json: {e}")
            raise ValueError(f"Invalid JSON in config.json: {e}")
        except IOError as e:
            logger.error(f"Failed to read config.json: {e}")
            raise ValueError(f"Failed to read config.json: {e}")
    
    raise ValueError("No configuration found. Set PPC_CONFIG environment variable or provide config.json")


def set_environment_variables(config: Dict[str, Any]) -> None:
    """
    Set environment variables from config for the optimizer
    The optimizer_core reads these environment variables for API authentication
    
    Args:
        config: Configuration dictionary
    """
    amazon_api = config.get('amazon_api', {})
    
    # Set required environment variables that optimizer_core expects
    os.environ['AMAZON_CLIENT_ID'] = amazon_api.get('client_id', '')
    os.environ['AMAZON_CLIENT_SECRET'] = amazon_api.get('client_secret', '')
    os.environ['AMAZON_REFRESH_TOKEN'] = amazon_api.get('refresh_token', '')
    
    logger.info("Environment variables set for optimizer")


def validate_credentials(config: Dict[str, Any]) -> None:
    """
    Validate required API credentials are present
    
    Args:
        config: Configuration dictionary
        
    Raises:
        ValueError: If required credentials are missing
    """
    required_fields = ['client_id', 'client_secret', 'refresh_token', 'profile_id']
    amazon_api = config.get('amazon_api', {})
    
    missing = [field for field in required_fields if not amazon_api.get(field, '').strip()]
    
    if missing:
        raise ValueError(f"Missing required API credentials: {', '.join(missing)}")
    
    logger.info("✓ All required credentials present")


def format_results_summary(results: Dict[str, Any], duration: float, dry_run: bool) -> str:
    """
    Format optimization results into email-friendly summary
    
    Args:
        results: Optimization results dictionary
        duration: Execution duration in seconds
        dry_run: Whether this was a dry run
        
    Returns:
        Formatted summary string
    """
    
    summary_lines = [
        f"Amazon PPC Optimization Report",
        f"{'=' * 50}",
        f"",
        f"Run Mode: {'DRY RUN (No changes made)' if dry_run else 'LIVE MODE'}",
        f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}",
        f"Duration: {duration:.2f} seconds",
        f"",
        f"Results:",
        f"-" * 50,
    ]
    
    # Add key metrics
    if isinstance(results, dict):
        if 'summary' in results:
            summary = results.get('summary', {})
            summary_lines.extend([
                f"Campaigns Analyzed: {summary.get('campaigns_analyzed', 0)}",
                f"Keywords Optimized: {summary.get('keywords_optimized', 0)}",
                f"Bids Adjusted: {summary.get('bids_adjusted', 0)}",
                f"Negative Keywords Added: {summary.get('negative_keywords_added', 0)}",
                f"Budget Changes: {summary.get('budget_changes', 0)}",
                f"",
            ])
        
        # Add performance highlights
        if 'highlights' in results:
            summary_lines.append("Performance Highlights:")
            highlights = results.get('highlights', [])
            for highlight in highlights:
                summary_lines.append(f"  • {highlight}")
            summary_lines.append("")
        
        # Add recommendations
        if 'recommendations' in results:
            summary_lines.append("Recommendations:")
            recommendations = results.get('recommendations', [])
            for rec in recommendations:
                summary_lines.append(f"  • {rec}")
            summary_lines.append("")
    
    summary_lines.extend([
        f"-" * 50,
        f"",
        f"For detailed insights, visit the dashboard:",
        f"{results.get('dashboard_url', 'Not configured') if isinstance(results, dict) else 'Not configured'}",
    ])
    
    return '\n'.join(summary_lines)


# For local testing
if __name__ == "__main__":
    class MockRequest:
        def __init__(self):
            self.args = {'dry_run': 'true'}
    
    result, status = run_optimizer(MockRequest())
    print(f"Status: {status}")
    print(f"Result: {json.dumps(result, indent=2)}")
