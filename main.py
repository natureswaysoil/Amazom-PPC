"""
Google Cloud Function Entry Point for Amazon PPC Optimizer
Triggered by Cloud Scheduler via HTTP request

This function automatically refreshes Amazon Advertising API tokens before making API calls.
Token refresh is handled automatically by the optimizer_core module.
"""

import json
import logging
import os
import sys
import traceback
import tempfile
from datetime import datetime
import functions_framework
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import requests

# Add parent directory to path to import optimizer
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Configure logging for Cloud Functions
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def create_config_file(config_dict):
    """
    Create a temporary config file from dictionary
    The optimizer_core expects a file path, so we create a temp file
    """
    import yaml
    temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False)
    yaml.dump(config_dict, temp_file)
    temp_file.close()
    return temp_file.name


def send_email_notification(subject, body, config):
    """Send email notification via SMTP"""
    try:
        email_config = config.get('email_notifications', {})
        if not email_config.get('enabled', False):
            logger.info("Email notifications disabled")
            return
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = email_config['from_email']
        msg['To'] = email_config['to_email']
        
        # Create HTML version
        html_body = f"""
        <html>
        <head></head>
        <body>
            <h2>{subject}</h2>
            <div style="font-family: Arial, sans-serif;">
                {body.replace(chr(10), '<br>')}
            </div>
            <hr>
            <p style="color: #666; font-size: 12px;">
                Generated by Amazon PPC Optimizer on Google Cloud Functions<br>
                Dashboard: <a href="{config.get('dashboard', {}).get('url', '#')}">View Dashboard</a>
            </p>
        </body>
        </html>
        """
        
        msg.attach(MIMEText(body, 'plain'))
        msg.attach(MIMEText(html_body, 'html'))
        
        # Send via SMTP
        with smtplib.SMTP(email_config['smtp_host'], email_config['smtp_port']) as server:
            server.starttls()
            server.login(email_config['smtp_user'], email_config['smtp_password'])
            server.send_message(msg)
        
        logger.info(f"Email notification sent to {email_config['to_email']}")
        
    except Exception as e:
        logger.error(f"Failed to send email: {str(e)}")


def update_dashboard(results, config, duration_seconds=0.0, dry_run=False, dashboard_client=None):
    """
    Send optimization results to the dashboard
    
    Args:
        results: Optimization results
        config: Configuration dictionary
        duration_seconds: Duration of optimization run
        dry_run: Whether this was a dry run
        dashboard_client: Optional DashboardClient instance (will create if not provided)
    """
    try:
        # Import dashboard client
        from dashboard_client import DashboardClient
        
        # Use provided client or create new one
        if dashboard_client is None:
            dashboard_client = DashboardClient(config)
        
        # Send results with enhanced payload
        success = dashboard_client.send_results(
            results=results,
            config=config,
            duration_seconds=duration_seconds,
            dry_run=dry_run
        )
        
        if success:
            logger.info("Dashboard updated successfully with enhanced payload")
        else:
            logger.warning("Dashboard update did not complete successfully")
            
    except Exception as e:
        # Dashboard errors should not stop optimization
        logger.error(f"Failed to update dashboard: {str(e)}")
        logger.debug("Optimization will continue despite dashboard error")


def is_valid_scheduler_request(request):
    """
    Validate that the request is from Cloud Scheduler
    
    Cloud Scheduler adds specific headers to requests:
    - X-CloudScheduler: true
    - X-CloudScheduler-JobName: job name
    - User-Agent: Google-Cloud-Scheduler
    
    Args:
        request: HTTP request object
        
    Returns:
        bool: True if request is from Cloud Scheduler or health check
    """
    # Check for Cloud Scheduler headers
    is_scheduler = (
        request.headers.get('X-CloudScheduler') == 'true' or
        request.headers.get('X-CloudScheduler-JobName') or
        'Google-Cloud-Scheduler' in request.headers.get('User-Agent', '')
    )
    
    if is_scheduler:
        logger.info(f"Valid Cloud Scheduler request from job: {request.headers.get('X-CloudScheduler-JobName', 'unknown')}")
        return True
    
    # Log unauthorized attempt
    logger.warning(f"Unauthorized request attempt from {request.remote_addr}")
    logger.warning(f"User-Agent: {request.headers.get('User-Agent', 'unknown')}")
    return False


def is_valid_dashboard_request(request):
    """
    Validate that the request is from the dashboard
    
    Args:
        request: HTTP request object
        
    Returns:
        bool: True if request has valid dashboard API key
    """
    try:
        config = load_config()
        expected_api_key = config.get('dashboard', {}).get('api_key', '')
        
        # If no API key configured, allow for backward compatibility
        if not expected_api_key:
            logger.warning("Dashboard API key not configured - allowing request")
            return True
        
        # Check Authorization header
        auth_header = request.headers.get('Authorization', '')
        
        if auth_header.startswith('Bearer '):
            provided_key = auth_header[7:]  # Remove 'Bearer ' prefix
            if provided_key == expected_api_key:
                logger.info("Valid dashboard API key")
                return True
        
        logger.warning("Invalid or missing dashboard API key")
        return False
        
    except Exception as e:
        logger.error(f"Error validating dashboard request: {e}")
        return False


@functions_framework.http
def run_optimizer(request):
    """
    Cloud Function entry point - triggered by Cloud Scheduler or Dashboard
    
    The optimizer automatically refreshes the Amazon Advertising API access token
    before making API calls using the refresh_token stored in environment variables.
    
    Includes:
    - Health check endpoint for uptime monitoring
    - Cloud Scheduler authentication validation
    - Dashboard trigger support with API key authentication
    - Proper error handling for unauthorized requests
    
    Args:
        request: HTTP request object (from Cloud Scheduler or Dashboard)
        
    Returns:
        Response object with execution results
    """
    
    # Health check endpoint - lightweight response for uptime monitoring
    if request.path == '/health' or request.args.get('health') == 'true':
        logger.info("Health check request received")
        return {
            'status': 'healthy',
            'service': 'amazon-ppc-optimizer',
            'timestamp': datetime.now().isoformat(),
            'version': '2.0.0'
        }, 200
    
    # Check if this is a dashboard trigger request
    is_dashboard_trigger = request.args.get('trigger') == 'dashboard' or request.path == '/trigger'
    
    if is_dashboard_trigger:
        # Validate dashboard API key
        if not is_valid_dashboard_request(request):
            return {
                'error': 'Unauthorized',
                'message': 'Valid dashboard API key required'
            }, 401
        logger.info("Optimization triggered by dashboard")
    else:
        # Validate Cloud Scheduler request
        if not is_valid_scheduler_request(request):
            return {
                'error': 'Unauthorized',
                'message': 'This function must be called by Cloud Scheduler or Dashboard'
            }, 401
    
    start_time = datetime.now()
    logger.info(f"=== Amazon PPC Optimizer Started at {start_time} ===")
    
    config_file_path = None
    dashboard_client = None
    
    try:
        # Load configuration from environment or file
        config = load_config()
        
        # Initialize dashboard client early for progress updates
        from dashboard_client import DashboardClient
        dashboard_client = DashboardClient(config)
        
        # Set environment variables for the optimizer
        # The optimizer reads credentials from environment variables
        set_environment_variables(config)
        
        # Validate required credentials
        validate_credentials(config)
        
        # Check if this is a dry run
        dry_run = request.args.get('dry_run', 'false').lower() == 'true'
        
        # Start optimization run and get run ID
        run_id = dashboard_client.start_run(dry_run=dry_run)
        logger.info(f"Starting optimization run: {run_id}")
        
        # Send progress: Initialization
        dashboard_client.send_progress("Initializing optimizer...", 10.0)
        
        # Create temporary config file for optimizer
        config_file_path = create_config_file(config)
        
        # Get profile ID
        profile_id = config.get('amazon_api', {}).get('profile_id')
        
        # Initialize optimizer
        logger.info("Initializing optimizer...")
        
        # Import here to ensure environment variables are set first
        from optimizer_core import PPCAutomation
        
        optimizer = PPCAutomation(
            config_path=config_file_path,
            profile_id=profile_id,
            dry_run=dry_run
        )
        
        # Send progress: Starting optimization
        dashboard_client.send_progress("Starting optimization...", 20.0)
        
        # Run optimization
        # The optimizer will automatically refresh the access token if needed
        logger.info("Running optimization (token refresh handled automatically)...")
        results = optimizer.run()
        
        # Send progress: Processing results
        dashboard_client.send_progress("Processing optimization results...", 90.0)
        
        # Update dashboard with final results
        logger.info("Updating dashboard with results...")
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        update_dashboard(results, config, duration, dry_run, dashboard_client)
        
        # Prepare summary
        summary = format_results_summary(results, duration, dry_run)
        
        # Send progress: Complete
        dashboard_client.send_progress("Optimization completed successfully", 100.0)
        
        # Send email notification
        if config.get('email_notifications', {}).get('send_on_completion', True):
            subject = f"Amazon PPC Optimization {'(DRY RUN) ' if dry_run else ''}Completed Successfully"
            send_email_notification(subject, summary, config)
        
        logger.info(f"=== Optimization Completed in {duration:.2f} seconds ===")
        
        return {
            'status': 'success',
            'message': 'Optimization completed successfully',
            'results': results,
            'duration_seconds': duration,
            'dry_run': dry_run,
            'run_id': run_id
        }, 200
        
    except Exception as e:
        error_msg = str(e)
        error_trace = traceback.format_exc()
        logger.error(f"Optimization failed: {error_msg}")
        logger.error(error_trace)
        
        # Report error to dashboard
        if dashboard_client:
            try:
                context = {
                    'timestamp': datetime.now().isoformat(),
                    'function': 'run_optimizer',
                    'dry_run': request.args.get('dry_run', 'false').lower() == 'true'
                }
                dashboard_client.send_error(e, context)
            except Exception as dashboard_error:
                logger.error(f"Failed to report error to dashboard: {dashboard_error}")
        
        # Send error notification
        try:
            config = load_config()
            if config.get('email_notifications', {}).get('send_on_error', True):
                subject = "Amazon PPC Optimization FAILED"
                body = f"""
Optimization Run Failed

Error: {error_msg}

Timestamp: {datetime.now().isoformat()}

Stack Trace:
{error_trace}

Please check the Cloud Functions logs for more details.
                """
                send_email_notification(subject, body, config)
        except:
            pass
        
        return {
            'status': 'error',
            'message': error_msg,
            'timestamp': datetime.now().isoformat()
        }, 500
    
    finally:
        # Clean up temp config file
        if config_file_path and os.path.exists(config_file_path):
            try:
                os.unlink(config_file_path)
            except:
                pass


def load_config():
    """Load configuration from environment variables or config file"""
    
    # Check if config is in environment variable (recommended for Cloud Functions)
    config_json = os.environ.get('PPC_CONFIG')
    if config_json:
        logger.info("Loading config from environment variable")
        return json.loads(config_json)
    
    # Fall back to config.json file
    config_file = os.path.join(os.path.dirname(__file__), 'config.json')
    if os.path.exists(config_file):
        logger.info(f"Loading config from {config_file}")
        with open(config_file, 'r') as f:
            return json.load(f)
    
    raise ValueError("No configuration found. Set PPC_CONFIG environment variable or provide config.json")


def set_environment_variables(config):
    """
    Set environment variables from config for the optimizer
    The optimizer_core reads these environment variables for API authentication
    """
    amazon_api = config.get('amazon_api', {})
    
    # Set required environment variables that optimizer_core expects
    os.environ['AMAZON_CLIENT_ID'] = amazon_api.get('client_id', '')
    os.environ['AMAZON_CLIENT_SECRET'] = amazon_api.get('client_secret', '')
    os.environ['AMAZON_REFRESH_TOKEN'] = amazon_api.get('refresh_token', '')
    
    logger.info("Environment variables set for optimizer")


def validate_credentials(config):
    """Validate required API credentials are present"""
    required_fields = ['client_id', 'client_secret', 'refresh_token', 'profile_id']
    amazon_api = config.get('amazon_api', {})
    
    missing = [field for field in required_fields if not amazon_api.get(field)]
    
    if missing:
        raise ValueError(f"Missing required API credentials: {', '.join(missing)}")
    
    logger.info("✓ All required credentials present")


def format_results_summary(results, duration, dry_run):
    """Format optimization results into email-friendly summary"""
    
    summary_lines = [
        f"Amazon PPC Optimization Report",
        f"{'=' * 50}",
        f"",
        f"Run Mode: {'DRY RUN (No changes made)' if dry_run else 'LIVE MODE'}",
        f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}",
        f"Duration: {duration:.2f} seconds",
        f"",
        f"Results:",
        f"-" * 50,
    ]
    
    # Add key metrics
    if isinstance(results, dict):
        if 'summary' in results:
            summary = results['summary']
            summary_lines.extend([
                f"Campaigns Analyzed: {summary.get('campaigns_analyzed', 0)}",
                f"Keywords Optimized: {summary.get('keywords_optimized', 0)}",
                f"Bids Adjusted: {summary.get('bids_adjusted', 0)}",
                f"Negative Keywords Added: {summary.get('negative_keywords_added', 0)}",
                f"Budget Changes: {summary.get('budget_changes', 0)}",
                f"",
            ])
        
        # Add performance highlights
        if 'highlights' in results:
            summary_lines.append("Performance Highlights:")
            for highlight in results['highlights']:
                summary_lines.append(f"  • {highlight}")
            summary_lines.append("")
        
        # Add recommendations
        if 'recommendations' in results:
            summary_lines.append("Recommendations:")
            for rec in results['recommendations']:
                summary_lines.append(f"  • {rec}")
            summary_lines.append("")
    
    summary_lines.extend([
        f"-" * 50,
        f"",
        f"For detailed insights, visit the dashboard:",
        f"{results.get('dashboard_url', 'Not configured') if isinstance(results, dict) else 'Not configured'}",
    ])
    
    return '\n'.join(summary_lines)


# For local testing
if __name__ == "__main__":
    class MockRequest:
        def __init__(self):
            self.args = {'dry_run': 'true'}
    
    result, status = run_optimizer(MockRequest())
    print(f"Status: {status}")
    print(f"Result: {json.dumps(result, indent=2)}")
