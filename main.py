import json
import logging
import os
import tempfile
from contextlib import contextmanager
from datetime import datetime
from typing import Dict, Optional, Tuple, Any
import functions_framework
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import requests
import yaml

from optimizer_core import PPCAutomation
from dashboard_client import DashboardClient

# Configure logging for Cloud Functions
# Detect if running in Cloud Functions environment
IS_CLOUD_FUNCTION = os.getenv('K_SERVICE') is not None or os.getenv('FUNCTION_TARGET') is not None

if IS_CLOUD_FUNCTION:
    # Use only StreamHandler for Cloud Functions (logs go to Cloud Logging)
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[logging.StreamHandler(sys.stdout)]
    )
else:
    # For local development, use both console and file logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler(f'ppc_main_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log')
        ]
    )

logger = logging.getLogger(__name__)


@contextmanager
def create_config_file(config_dict: Dict) -> str:
    """
    Create a temporary config file from dictionary using context manager
    The optimizer_core expects YAML format file, so we ensure consistent format handling
    
    Args:
        config_dict: Configuration dictionary (from JSON or other source)
        
    Yields:
        Path to temporary YAML config file
        
    Raises:
        ValueError: If config_dict is invalid
        IOError: If file creation fails
    """
    if not isinstance(config_dict, dict):
        raise ValueError("config_dict must be a dictionary")
    
    temp_file = None
    try:
        # Create temp file with YAML format (optimizer_core expects YAML)
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False, encoding='utf-8')
        yaml.dump(config_dict, temp_file, default_flow_style=False, allow_unicode=True)
        temp_file.close()
        logger.info(f"Created temporary config file: {temp_file.name}")
        yield temp_file.name
    except Exception as e:
        logger.error(f"Failed to create config file: {e}")
        if temp_file and os.path.exists(temp_file.name):
            try:
                os.unlink(temp_file.name)
            except Exception as cleanup_err:
                logger.warning(f"Failed to cleanup temp file: {cleanup_err}")
        raise
    finally:
        # Cleanup temp file
        if temp_file and os.path.exists(temp_file.name):
            try:
                os.unlink(temp_file.name)
                logger.debug(f"Cleaned up temporary config file: {temp_file.name}")
            except Exception as e:
                logger.warning(f"Failed to cleanup temp file {temp_file.name}: {e}")

def _resolve_config_path(request_data: Dict[str, Any]) -> str:
    request_path = request_data.get("config_path")
    if request_path:
        if os.path.exists(request_path):
            return request_path
        logger.warning("Requested config_path '%s' was not found; falling back to defaults", request_path)

def send_email_notification(subject: str, body: str, config: Dict) -> bool:
    """
    Send email notification via SMTP with retry logic
    
    Args:
        subject: Email subject line
        body: Plain text email body
        config: Configuration dictionary containing email settings
        
    Returns:
        True if email sent successfully, False otherwise
    """
    try:
        email_config = config.get('email_notifications', {})
        if not email_config.get('enabled', False):
            logger.info("Email notifications disabled")
            return True
        
        # Validate required email config fields
        required_fields = ['smtp_host', 'smtp_port', 'smtp_user', 'smtp_password', 'from_email', 'to_email']
        missing_fields = [field for field in required_fields if not email_config.get(field)]
        if missing_fields:
            logger.error(f"Missing required email configuration fields: {', '.join(missing_fields)}")
            return False
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = email_config['from_email']
        msg['To'] = email_config['to_email']
        
        # Create HTML version
        dashboard_url = config.get('dashboard', {}).get('url', '#')
        html_body = f"""
        <html>
        <head></head>
        <body>
            <h2>{subject}</h2>
            <div style="font-family: Arial, sans-serif;">
                {body.replace(chr(10), '<br>')}
            </div>
            <hr>
            <p style="color: #666; font-size: 12px;">
                Generated by Amazon PPC Optimizer on Google Cloud Functions<br>
                Dashboard: <a href="{dashboard_url}">View Dashboard</a>
            </p>
        </body>
        </html>
        """
        
        msg.attach(MIMEText(body, 'plain'))
        msg.attach(MIMEText(html_body, 'html'))
        
        # Send via SMTP with retry logic
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                with smtplib.SMTP(email_config['smtp_host'], int(email_config['smtp_port']), timeout=30) as server:
                    server.starttls()
                    server.login(email_config['smtp_user'], email_config['smtp_password'])
                    server.send_message(msg)
                
                logger.info(f"Email notification sent to {email_config['to_email']}")
                return True
                
            except (smtplib.SMTPException, OSError) as smtp_err:
                if attempt < max_retries - 1:
                    logger.warning(f"Email send attempt {attempt + 1}/{max_retries} failed: {smtp_err}. Retrying...")
                    import time
                    time.sleep(retry_delay * (attempt + 1))
                else:
                    logger.error(f"Failed to send email after {max_retries} attempts: {smtp_err}")
                    return False
        
        return False
        
    except Exception as e:
        logger.error(f"Failed to send email notification: {str(e)}")
        return False


def update_dashboard(results: Dict, config: Dict) -> bool:
    """
    Send optimization results to the dashboard
    
    Args:
        results: Optimization results dictionary
        config: Configuration dictionary containing dashboard settings
        
    Returns:
        True if dashboard updated successfully, False otherwise
    """
    try:
        dashboard_url = config.get('dashboard', {}).get('url', None)
        if not dashboard_url:
            logger.warning("Dashboard URL not configured, skipping dashboard update")
            return True
        
        # Send POST request to dashboard API endpoint
        api_endpoint = f"{dashboard_url}/api/optimization-results"
        
        payload = {
            'timestamp': datetime.now().isoformat(),
            'results': results,
            'status': 'success'
        }
        
        response = requests.post(
            api_endpoint,
            json=payload,
            headers={'Content-Type': 'application/json'},
            timeout=10
        )
        
        if response.status_code == 200:
            logger.info("Dashboard updated successfully")
            return True
        else:
            logger.warning(f"Dashboard update returned status {response.status_code}")
            return False
            
    except Exception as e:
        logger.error(f"Failed to update dashboard: {str(e)}")
        return False


@functions_framework.http
def run_optimizer(request) -> Tuple[Dict[str, Any], int]:
    """
    Cloud Function entry point - triggered by Cloud Scheduler
    
    The optimizer automatically refreshes the Amazon Advertising API access token
    before making API calls using the refresh_token stored in environment variables.
    
    Args:
        request: HTTP request object (from Cloud Scheduler)
        
    Returns:
        Tuple of (response dictionary, HTTP status code)
    """
    
    start_time = datetime.now()
    logger.info(f"=== Amazon PPC Optimizer Started at {start_time} ===")
    
    try:
        # Load configuration from environment or file
        config = load_config()
        
        # Set environment variables for the optimizer
        # The optimizer reads credentials from environment variables
        set_environment_variables(config)
        
        # Validate required credentials
        validate_credentials(config)
        
        # Check if this is a dry run
        dry_run = request.args.get('dry_run', 'false').lower() == 'true'
        
        # Use context manager for temp config file (ensures cleanup)
        with create_config_file(config) as config_file_path:
            # Get profile ID with default value
            profile_id = config.get('amazon_api', {}).get('profile_id', '')
            if not profile_id:
                raise ValueError("profile_id is required in amazon_api configuration")
            
            # Initialize optimizer
            logger.info("Initializing optimizer...")
            
            # Import here to ensure environment variables are set first
            from optimizer_core import PPCAutomation
            
            optimizer = PPCAutomation(
                config_path=config_file_path,
                profile_id=profile_id,
                dry_run=dry_run
            )
            
            # Run optimization
            # The optimizer will automatically refresh the access token if needed
            logger.info("Running optimization (token refresh handled automatically)...")
            results = optimizer.run()
        
        # Update dashboard
        logger.info("Updating dashboard...")
        update_dashboard(results, config)
        
        # Prepare summary
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        summary = format_results_summary(results, duration, dry_run)
        
        # Send email notification
        if config.get('email_notifications', {}).get('send_on_completion', True):
            subject = f"Amazon PPC Optimization {'(DRY RUN) ' if dry_run else ''}Completed Successfully"
            send_email_notification(subject, summary, config)
        
        logger.info(f"=== Optimization Completed in {duration:.2f} seconds ===")
        
        return {
            'status': 'success',
            'message': 'Optimization completed successfully',
            'results': results,
            'duration_seconds': duration,
            'dry_run': dry_run
        }, 200
        
    except Exception as e:
        error_msg = str(e)
        error_trace = traceback.format_exc()
        logger.error(f"Optimization failed: {error_msg}")
        logger.error(error_trace)
        
        # Send error notification
        try:
            config = load_config()
            if config.get('email_notifications', {}).get('send_on_error', True):
                subject = "Amazon PPC Optimization FAILED"
                body = f"""
Optimization Run Failed

Error: {error_msg}

Timestamp: {datetime.now().isoformat()}

Stack Trace:
{error_trace}

Please check the Cloud Functions logs for more details.
                """
                send_email_notification(subject, body, config)
        except Exception as notification_err:
            logger.warning(f"Failed to send error notification: {notification_err}")
        
        return {
            'status': 'error',
            'message': error_msg,
            'timestamp': datetime.now().isoformat()
        }, 500

    if not isinstance(request_json, dict):
        logger.warning("Request JSON body is not an object; ignoring payload")
        request_json = {}

def load_config() -> Dict[str, Any]:
    """
    Load configuration from environment variables or config file
    
    Returns:
        Configuration dictionary loaded from JSON
        
    Raises:
        ValueError: If no valid configuration is found
        json.JSONDecodeError: If JSON parsing fails
    """
    
    # Check if config is in environment variable (recommended for Cloud Functions)
    config_json = os.environ.get('PPC_CONFIG', None)
    if config_json:
        logger.info("Loading config from environment variable")
        try:
            config = json.loads(config_json)
            logger.info("Configuration successfully loaded from environment variable")
            return config
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse PPC_CONFIG JSON: {e}")
            raise ValueError(f"Invalid JSON in PPC_CONFIG environment variable: {e}")
    
    # Fall back to config.json file
    config_file = os.path.join(os.path.dirname(__file__), 'config.json')
    if os.path.exists(config_file):
        logger.info(f"Loading config from {config_file}")
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            logger.info(f"Configuration successfully loaded from {config_file}")
            return config
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse config.json: {e}")
            raise ValueError(f"Invalid JSON in config.json: {e}")
        except IOError as e:
            logger.error(f"Failed to read config.json: {e}")
            raise ValueError(f"Failed to read config.json: {e}")
    
    raise ValueError("No configuration found. Set PPC_CONFIG environment variable or provide config.json")


def set_environment_variables(config: Dict[str, Any]) -> None:
    """
    Set environment variables from config for the optimizer
    The optimizer_core reads these environment variables for API authentication
    
    Args:
        config: Configuration dictionary
    """
    amazon_api = config.get('amazon_api', {})
    
    # Set required environment variables that optimizer_core expects
    os.environ['AMAZON_CLIENT_ID'] = amazon_api.get('client_id', '')
    os.environ['AMAZON_CLIENT_SECRET'] = amazon_api.get('client_secret', '')
    os.environ['AMAZON_REFRESH_TOKEN'] = amazon_api.get('refresh_token', '')
    
    logger.info("Environment variables set for optimizer")


def validate_credentials(config: Dict[str, Any]) -> None:
    """
    Validate required API credentials are present
    
    Args:
        config: Configuration dictionary
        
    Raises:
        ValueError: If required credentials are missing
    """
    required_fields = ['client_id', 'client_secret', 'refresh_token', 'profile_id']
    amazon_api = config.get('amazon_api', {})
    
    missing = [field for field in required_fields if not amazon_api.get(field, '').strip()]
    
    if missing:
        raise ValueError(f"Missing required API credentials: {', '.join(missing)}")
    
    logger.info("✓ All required credentials present")


def format_results_summary(results: Dict[str, Any], duration: float, dry_run: bool) -> str:
    """
    Format optimization results into email-friendly summary
    
    Args:
        results: Optimization results dictionary
        duration: Execution duration in seconds
        dry_run: Whether this was a dry run
        
    Returns:
        Formatted summary string
    """
    
    summary_lines = [
        f"Amazon PPC Optimization Report",
        f"{'=' * 50}",
        f"",
        f"Run Mode: {'DRY RUN (No changes made)' if dry_run else 'LIVE MODE'}",
        f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}",
        f"Duration: {duration:.2f} seconds",
        f"",
        f"Results:",
        f"-" * 50,
    ]
    
    # Add key metrics
    if isinstance(results, dict):
        if 'summary' in results:
            summary = results.get('summary', {})
            summary_lines.extend([
                f"Campaigns Analyzed: {summary.get('campaigns_analyzed', 0)}",
                f"Keywords Optimized: {summary.get('keywords_optimized', 0)}",
                f"Bids Adjusted: {summary.get('bids_adjusted', 0)}",
                f"Negative Keywords Added: {summary.get('negative_keywords_added', 0)}",
                f"Budget Changes: {summary.get('budget_changes', 0)}",
                f"",
            ])
        
        # Add performance highlights
        if 'highlights' in results:
            summary_lines.append("Performance Highlights:")
            highlights = results.get('highlights', [])
            for highlight in highlights:
                summary_lines.append(f"  • {highlight}")
            summary_lines.append("")
        
        # Add recommendations
        if 'recommendations' in results:
            summary_lines.append("Recommendations:")
            recommendations = results.get('recommendations', [])
            for rec in recommendations:
                summary_lines.append(f"  • {rec}")
            summary_lines.append("")
    
    summary_lines.extend([
        f"-" * 50,
        f"",
        f"For detailed insights, visit the dashboard:",
        f"{results.get('dashboard_url', 'Not configured') if isinstance(results, dict) else 'Not configured'}",
    ])
    
    return '\n'.join(summary_lines)


# For local testing
if __name__ == "__main__":
    class MockRequest:
        def __init__(self):
            self.args = {'dry_run': 'true'}
    
    result, status = run_optimizer(MockRequest())
    print(f"Status: {status}")
    print(f"Result: {json.dumps(result, indent=2)}")
