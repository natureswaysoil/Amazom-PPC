"""
Google Cloud Function Entry Point for Amazon PPC Optimizer
Triggered by Cloud Scheduler via HTTP request

This function automatically refreshes Amazon Advertising API tokens before making API calls.
Token refresh is handled automatically by the optimizer_core module.
"""

import json
import logging
import os
import sys
import traceback
import tempfile
from datetime import datetime
import functions_framework
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import requests

# Add parent directory to path to import optimizer
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Configure logging for Cloud Functions
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def create_config_file(config_dict):
    """
    Create a temporary config file from dictionary
    The optimizer_core expects a file path, so we create a temp file
    """
    import yaml
    temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False)
    yaml.dump(config_dict, temp_file)
    temp_file.close()
    return temp_file.name


def send_email_notification(subject, body, config):
    """Send email notification via SMTP"""
    try:
        email_config = config.get('email_notifications', {})
        if not email_config.get('enabled', False):
            logger.info("Email notifications disabled")
            return
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = email_config['from_email']
        msg['To'] = email_config['to_email']
        
        # Create HTML version
        html_body = f"""
        <html>
        <head></head>
        <body>
            <h2>{subject}</h2>
            <div style="font-family: Arial, sans-serif;">
                {body.replace(chr(10), '<br>')}
            </div>
            <hr>
            <p style="color: #666; font-size: 12px;">
                Generated by Amazon PPC Optimizer on Google Cloud Functions<br>
                Dashboard: <a href="{config.get('dashboard', {}).get('url', '#')}">View Dashboard</a>
            </p>
        </body>
        </html>
        """
        
        msg.attach(MIMEText(body, 'plain'))
        msg.attach(MIMEText(html_body, 'html'))
        
        # Send via SMTP
        with smtplib.SMTP(email_config['smtp_host'], email_config['smtp_port']) as server:
            server.starttls()
            server.login(email_config['smtp_user'], email_config['smtp_password'])
            server.send_message(msg)
        
        logger.info(f"Email notification sent to {email_config['to_email']}")
        
    except Exception as e:
        logger.error(f"Failed to send email: {str(e)}")


def update_dashboard(results, config):
    """Send optimization results to the dashboard"""
    try:
        dashboard_url = config.get('dashboard', {}).get('url')
        if not dashboard_url:
            logger.warning("Dashboard URL not configured")
            return
        
        # Send POST request to dashboard API endpoint
        api_endpoint = f"{dashboard_url}/api/optimization-results"
        
        payload = {
            'timestamp': datetime.now().isoformat(),
            'results': results,
            'status': 'success'
        }
        
        response = requests.post(
            api_endpoint,
            json=payload,
            headers={'Content-Type': 'application/json'},
            timeout=10
        )
        
        if response.status_code == 200:
            logger.info("Dashboard updated successfully")
        else:
            logger.warning(f"Dashboard update returned status {response.status_code}")
            
    except Exception as e:
        logger.error(f"Failed to update dashboard: {str(e)}")


def is_valid_scheduler_request(request):
    """
    Validate that the request is from Cloud Scheduler
    
    Cloud Scheduler adds specific headers to requests:
    - X-CloudScheduler: true
    - X-CloudScheduler-JobName: job name
    - User-Agent: Google-Cloud-Scheduler
    
    Args:
        request: HTTP request object
        
    Returns:
        bool: True if request is from Cloud Scheduler or health check
    """
    # Check for Cloud Scheduler headers
    is_scheduler = (
        request.headers.get('X-CloudScheduler') == 'true' or
        request.headers.get('X-CloudScheduler-JobName') or
        'Google-Cloud-Scheduler' in request.headers.get('User-Agent', '')
    )
    
    if is_scheduler:
        logger.info(f"Valid Cloud Scheduler request from job: {request.headers.get('X-CloudScheduler-JobName', 'unknown')}")
        return True
    
    # Log unauthorized attempt
    logger.warning(f"Unauthorized request attempt from {request.remote_addr}")
    logger.warning(f"User-Agent: {request.headers.get('User-Agent', 'unknown')}")
    return False


@functions_framework.http
def run_optimizer(request):
    """
    Cloud Function entry point - triggered by Cloud Scheduler
    
    The optimizer automatically refreshes the Amazon Advertising API access token
    before making API calls using the refresh_token stored in environment variables.
    
    Includes:
    - Health check endpoint for uptime monitoring
    - Cloud Scheduler authentication validation
    - Proper error handling for unauthorized requests
    
    Args:
        request: HTTP request object (from Cloud Scheduler)
        
    Returns:
        Response object with execution results
    """
    
    # Health check endpoint - lightweight response for uptime monitoring
    if request.path == '/health' or request.args.get('health') == 'true':
        logger.info("Health check request received")
        return {
            'status': 'healthy',
            'service': 'amazon-ppc-optimizer',
            'timestamp': datetime.now().isoformat()
        }, 200
    
    # Validate Cloud Scheduler request
    if not is_valid_scheduler_request(request):
        return {
            'error': 'Unauthorized',
            'message': 'This function must be called by Cloud Scheduler'
        }, 401
    
    start_time = datetime.now()
    logger.info(f"=== Amazon PPC Optimizer Started at {start_time} ===")
    
    config_file_path = None
    
    try:
        # Load configuration from environment or file
        config = load_config()
        
        # Set environment variables for the optimizer
        # The optimizer reads credentials from environment variables
        set_environment_variables(config)
        
        # Validate required credentials
        validate_credentials(config)
        
        # Check if this is a dry run
        dry_run = request.args.get('dry_run', 'false').lower() == 'true'
        
        # Create temporary config file for optimizer
        config_file_path = create_config_file(config)
        
        # Get profile ID
        profile_id = config.get('amazon_api', {}).get('profile_id')
        
        # Initialize optimizer
        logger.info("Initializing optimizer...")
        
        # Import here to ensure environment variables are set first
        from optimizer_core import PPCAutomation
        
        optimizer = PPCAutomation(
            config_path=config_file_path,
            profile_id=profile_id,
            dry_run=dry_run
        )
        
        # Run optimization
        # The optimizer will automatically refresh the access token if needed
        logger.info("Running optimization (token refresh handled automatically)...")
        results = optimizer.run()
        
        # Update dashboard
        logger.info("Updating dashboard...")
        update_dashboard(results, config)
        
        # Prepare summary
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        summary = format_results_summary(results, duration, dry_run)
        
        # Send email notification
        if config.get('email_notifications', {}).get('send_on_completion', True):
            subject = f"Amazon PPC Optimization {'(DRY RUN) ' if dry_run else ''}Completed Successfully"
            send_email_notification(subject, summary, config)
        
        logger.info(f"=== Optimization Completed in {duration:.2f} seconds ===")
        
        return {
            'status': 'success',
            'message': 'Optimization completed successfully',
            'results': results,
            'duration_seconds': duration,
            'dry_run': dry_run
        }, 200
        
    except Exception as e:
        error_msg = str(e)
        error_trace = traceback.format_exc()
        logger.error(f"Optimization failed: {error_msg}")
        logger.error(error_trace)
        
        # Send error notification
        try:
            config = load_config()
            if config.get('email_notifications', {}).get('send_on_error', True):
                subject = "Amazon PPC Optimization FAILED"
                body = f"""
Optimization Run Failed

Error: {error_msg}

Timestamp: {datetime.now().isoformat()}

Stack Trace:
{error_trace}

Please check the Cloud Functions logs for more details.
                """
                send_email_notification(subject, body, config)
        except:
            pass
        
        return {
            'status': 'error',
            'message': error_msg,
            'timestamp': datetime.now().isoformat()
        }, 500
    
    finally:
        # Clean up temp config file
        if config_file_path and os.path.exists(config_file_path):
            try:
                os.unlink(config_file_path)
            except:
                pass


def load_config():
    """Load configuration from environment variables or config file"""
    
    # Check if config is in environment variable (recommended for Cloud Functions)
    config_json = os.environ.get('PPC_CONFIG')
    if config_json:
        logger.info("Loading config from environment variable")
        return json.loads(config_json)
    
    # Fall back to config.json file
    config_file = os.path.join(os.path.dirname(__file__), 'config.json')
    if os.path.exists(config_file):
        logger.info(f"Loading config from {config_file}")
        with open(config_file, 'r') as f:
            return json.load(f)
    
    raise ValueError("No configuration found. Set PPC_CONFIG environment variable or provide config.json")


def set_environment_variables(config):
    """
    Set environment variables from config for the optimizer
    The optimizer_core reads these environment variables for API authentication
    """
    amazon_api = config.get('amazon_api', {})
    
    # Set required environment variables that optimizer_core expects
    os.environ['AMAZON_CLIENT_ID'] = amazon_api.get('client_id', '')
    os.environ['AMAZON_CLIENT_SECRET'] = amazon_api.get('client_secret', '')
    os.environ['AMAZON_REFRESH_TOKEN'] = amazon_api.get('refresh_token', '')
    
    logger.info("Environment variables set for optimizer")


def validate_credentials(config):
    """Validate required API credentials are present"""
    required_fields = ['client_id', 'client_secret', 'refresh_token', 'profile_id']
    amazon_api = config.get('amazon_api', {})
    
    missing = [field for field in required_fields if not amazon_api.get(field)]
    
    if missing:
        raise ValueError(f"Missing required API credentials: {', '.join(missing)}")
    
    logger.info("✓ All required credentials present")


def format_results_summary(results, duration, dry_run):
    """Format optimization results into email-friendly summary"""
    
    summary_lines = [
        f"Amazon PPC Optimization Report",
        f"{'=' * 50}",
        f"",
        f"Run Mode: {'DRY RUN (No changes made)' if dry_run else 'LIVE MODE'}",
        f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}",
        f"Duration: {duration:.2f} seconds",
        f"",
        f"Results:",
        f"-" * 50,
    ]
    
    # Add key metrics
    if isinstance(results, dict):
        if 'summary' in results:
            summary = results['summary']
            summary_lines.extend([
                f"Campaigns Analyzed: {summary.get('campaigns_analyzed', 0)}",
                f"Keywords Optimized: {summary.get('keywords_optimized', 0)}",
                f"Bids Adjusted: {summary.get('bids_adjusted', 0)}",
                f"Negative Keywords Added: {summary.get('negative_keywords_added', 0)}",
                f"Budget Changes: {summary.get('budget_changes', 0)}",
                f"",
            ])
        
        # Add performance highlights
        if 'highlights' in results:
            summary_lines.append("Performance Highlights:")
            for highlight in results['highlights']:
                summary_lines.append(f"  • {highlight}")
            summary_lines.append("")
        
        # Add recommendations
        if 'recommendations' in results:
            summary_lines.append("Recommendations:")
            for rec in results['recommendations']:
                summary_lines.append(f"  • {rec}")
            summary_lines.append("")
    
    summary_lines.extend([
        f"-" * 50,
        f"",
        f"For detailed insights, visit the dashboard:",
        f"{results.get('dashboard_url', 'Not configured') if isinstance(results, dict) else 'Not configured'}",
    ])
    
    return '\n'.join(summary_lines)


# For local testing
if __name__ == "__main__":
    class MockRequest:
        def __init__(self):
            self.args = {'dry_run': 'true'}
    
    result, status = run_optimizer(MockRequest())
    print(f"Status: {status}")
    print(f"Result: {json.dumps(result, indent=2)}")
